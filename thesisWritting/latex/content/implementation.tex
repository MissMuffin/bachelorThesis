\textit{Google’s IDE Android Studio 2.1.2 was used for the implementation of the Android app prototype}

\section{Stitch symbols}
There are different ways to display a stitch symbol in an Android app --- this section will give an overview of the possiblities and the solution chosen for the prototype. 
Since the View class already defines a canvas object with dedicated functions for drawing image and text content in its onDraw() method, it offers a good starting point. To decide between using the image or text format for disoplaying stitch symbols, a further look into what each format entails is necessary. Using image resources 

Image content needs to be specified in an Android project in the res directory under the drawable directory. This directory contains the image resources of the app, the drawables --- this applies for icons, custom images, and other image content, excempting the launcher icon of the app, which is located in the mipmap directory. One way to use stitch symbols in an Android app would be to add every symbol as a drawable resource, and then draw those resources to the canvas of a view. For this a drawable would be needed for each individual stitch symbol, as well as way to map these drawable files to values that can be efficiently stored in a \gls{json} file. The usage of many drawables in an app would also lead to an increase in app size, resulting in longer download times and larger storage demands. Both are an inconvinience to the user and can be problematic on older devices with less powerful hardware, making the app unsusable in the worst case scenario.
The other option for displaying symbols is to create a custom \gls{TTF} with glyphs for stitch symbols that is applied to text in the app. This is the solution used in the prototype. It offers several advantages over using image resources. For one, when using drawables it might be necessary to include several versions of the same file to assure that they are displayed correctly on devices with different screen densities (\cite{android_densities}). This is not needed for text with a custom font: the glyphs are defined by Beziér curves, which are correctly rendered by the system for the individual screen densities. \todo{ref here?} The usage of a font also allows to write each stitch as a characters, simplifying the process of saving a pattern to a \gls{json} file. For OpenType fonts, which \gls{TTF} belongs to, Microsoft recommends 64000 as the maximum number of glyphs a font should contain (\cite{microsoft_max_glyphs}). This allows for a plethora of stitch symbols. The open source program FontForge \footnote{\url{https://fontforge.github.io/en-US/} (last accessed: 08-10-2016)} was used creation of the custom \gls{TTF} knitting font used in the protoype. The knitting font contains a selection of 16 stitch symbols whose glyphs were defined by the author herself. The glyphs and their corresponding UTF-8 characters can be found in the Appendix A: \todo{ref here!}.

\section{Pattern and Parsing between Pattern Formats}
Using a custom font for the stitch symbols allows for presenting patterns as a combinations of characters. The actual pattern chart is saved to a \gls{json} file as an Array of Strings, where each String represents one row in the chart. For this a Pattern \gls{pojo} is used. It contains fields for the number of columns and rows, the current row set in the counter, and an array of strings, where each string represents a row in the pattern. A pattern object’s default state after initialization contains a pattern of the size 10 x 10  cells that is filled with the string representing an empty stitch --- an empty stitch is represented by ``Z''in the prototype. The class Pattern is a subclass of Metadata.java, a class containing fields for a pattern name and a \gls{uuid}. More about the Metadata class can be found in \ref{implementation_storage}.

The pattern in the Pattern \gls{pojo} is saved in the shortened row notation. To display the pattern in the grid and row format, the pattern needs to be parsed into forms that are usable by both formats. For that the class PatternParser.java is used. It converts between the array of strings used in the Pattern \gls{pojo}, a two-dimensional array of strings used in the PatternGridView (\ref{impl_grid_format}), and a single string with linefeeds used in the row format's Edittext widget (\ref{impl_row_format}). For a more detailed explanation of the pattern notation forms refer to the corresponding sections.

\section{Persistent Disk Storage}
\label{implementation_storage}
There are multiple ways persistent storage can be implemented in Android. A common choice is to use a SQLite database, which Android natively supports (\cite{android_saving_data}). Another choice is to save data in files. The prototype implements the latter, since it reduces the export of files to a simple matter of copying to a different directory. Therefore, instead of using a database, the protoype saves \gls{json} files to the disk. This can be done either in internal or external storage, as explained in \ref{android_storage}. Since permament accessibility of files cannot be ensured for files located on the external storage, the pattern files are saved in internal storage, in the default directory that Android allocates for the app, and are exported to the user-accessible external storage. 

For this a Pattern \gls{pojo} is serialized using Google’s \gls{json} library Gson, which handles the marshalling and unmarshalling of the files to Java objects and vice versa. Gson supports the usage of Java generics and can map \gls{json} data to \gls{pojo}s while maintaining inheritance hierarchies\todo{cite here}. The corresponding code can be in found the class PatternStorage.java\todo{ref here}.

The Pattern class inherits from the class Metadata which contains both a \gls{uuid} which is used as a pattern's file name and the pattern name that is given by the user. When storing on disk, Pattern \gls{pojo}s are converted to \gls{json} using Gson and saved with the \gls{uuid} as filename. Before that the metadata of the pattern is added to a local ArrayList of Metadatas in the PatternStorage class.  This ArrayList in turn is marshalled to \gls{json} and saved to the same directory as the pattern files. It acts as an index of all patterns saved on the device. Using this index file increases performance, since not all pattern files, with their potentially big pattern data, have to be accessed and unmarshalled --- instead only the lightweight metadata files need to be loaded. Individual pattern can then be loaded using the \gls{uuid} saved in the patterns Metadata.

\section{Displaying a Pattern}

\subsection{Grid Format}
\label{impl_grid_format}
When considering presenting data in a grid format, the most obvious solution is to first look at Android's own implementations of grids. Promising 
starting points for that are the TableLayout and the GridView class. After a brief investigation into the TableLayout, it quickly becomes apparent, that this layout is intended more as a way to position views, than to represent data in a grid. It can be likened to the HTML table tag (\cite{android_tablelayout}), which is also used to position views within the constraints of cells, columns, and rows.

Android's GridView class, on the other hand, is designed with notion of displaying data. Each cell represents one data entry in a collection of data, the displaying of which is handled by an Adapter class attached to the grid view. Android ships with a specialized adapter for lists \footnote{\url{https://developer.android.com/reference/android/widget/ListAdapter.html} (accessed: 11-08-2016)}, as well as a BaseAdapter that can be subclassed for a custom handling and presentation of data. While this is a fitting solution for displaying symbols in a grid, it does not meet the requirements this project sets for the grid format. It is required that the column and row numbers are displayed next to the grid as axes. These axes should scale and scroll together with the grid, but should not be scrolled outside the visible area, since the user would not be able to know the cell position then. For one, the GridView class does not support frozen cells, columns, or rows --- as far as the author of this thesis was able to research. If the column numbers were to be displayed in the first row of the grid, they would move offscreen upon scrolling the grid. A possible solution to this would to use text views to act as axes to the grid and to display the column and row numbers next to it. Problematic with this approach would be the fine-tuning required to math the visuals of the text view to that of the grid. Line height, text size and the synchronization with scrolls and zooms performed on the grid would need to match perfectly. Since this does not classify as intended behavior for these views, a cohesive \gls{UI} cannot be guaranteed. Furthermore, Android does not offer two dimensional scroll on any view except its WebView\footnote{\url{https://developer.android.com/reference/android/webkit/WebView.html} (accessed: 11-08-2016)} -- the GridView class natively only supports vertical scroll.

Therefore, in order to fulfill all requirements it makes the most sense to create a custom implementation of a view that supports the display of text in a grid, two-dimensional scroll, zoom, and axes that stick to the view bounds. Google's sample project \textit{Interactive Chart}\footnote{\url{https://developer.android.com/shareables/training/InteractiveChart.zip} (accessed: 11-08-2016) A digital copy of this project can also be found on the CD attached to this thesis.} and the corresponding training path\footnote{\url{https://developer.android.com/training/gestures/scale.html##drag} (accessed: 11-08-2016)} present an implementation example and were used as a guide line for the implementation of the class PatternGridView.java \todo{reference here}. This class keeps a reference to a two-dimensional array of strings which represents the pattern with its columns and rows\todo{code example 2d array to show columns and rows}. The grid and its axes are drawn by overriding the onDraw() method, calulating the postion of the correspoinding lines and numbers with the dimensions of the view and pre-defined, hardcoded values for cell width and margin. The current version of the PatternGridView uses a SimpleOnGestureListener\todo{ref here} to compute two-dimensional dragging. Android defines two different scrolling types for views: dragging and flinging (\cite{android_scrolling_types}). Dragging is executed by draging a finger across the device's touchscreen and results in a moving of the view corresponding to the dragging direction and speed. This means, that no matter the velocity of the dragging gesture, the view won't keep moving once the user lifts the finger involved in the gesture. A fling on the other hand will keep moving the view with a speed and duration exponential to the velocity of the fling gesture, where the duration is calculated by introducing a friction to the scroll. This gesture can also be describe as a swiping motion performed on the touchscreen. Even after the finger has been lifted of the screen the fling continues to execute until it either runs its course or is interrupted.

The current version of the PatternGridView implements a simple dragging gesture and does not support flinging as of yet. For this a variable of type Point\todo{ref docs point class} is saved locally to represent the offset scrolled. It is initiliazed with the value (0,0) and updated on every motion event that is recognized as dragging. The necessary calculations for these updates are done by overriding the onSCroll()\todo{ref} method in a custom SimpleOnGestureListener. This method has access to the horizontal and vertical distance scrolled, which is substracted from the offset. This is done because the value of the distance is positive when dragging towards the point of origin (the top left corner) and negative when dragging away from it. Therefore, the canvas needs to be translated in the opposite distance. The offset is then clamped to minimum and maximum values, to ensure that the grid will never completely move offscreen: 

\begin{gather*}
offset_{min} = (0, 0)
\end{gather*}
\begin{align*}
offset_{max} = (&width_{view} - width_{content} - 2 * margin, \\
				&height_{view} - height_{content} - 2 * margin)
\end{align*}

where margin is the distance of the grid from the top and left view edges that is reserved for the axes text.

Similiarly to dragging, scaling is implemented with a SimpleOnScaleGestureListener\todo{ref here} with is connected to the view's onTouchEvent(). The scaling factor is then clamped at pre-defined maximum and minimum values and saved in a variable. During the drawing operations of the grid, axes, and text the scaling factor is then used to compute and draw the scaled visuals. On user touch on the grid the touched cell is calculated from the pixel position of the touch event and the currently selected stitch string is saved to that position in the two-dimensional pattern array. Following this the view is invalidated\todo{ref to method in docs here} and re-drawn with updated pattern.   

\subsection{Row Format}
\label{impl_row_format}

requirements: 
	editor should have standard text editor functionalities: copy, paste, cut, select, multi lines, scollable horizontally and zoom
problem:
	texteditor has standard functions (cut, copy, select, paste) 
	also has multi lines as well as horizontal scroll
	but doesn't support multi line and hori scroll at the same time
	if scroll, then only single line
	if multi line, then vertical scroll and wrap at the end of the screen, no content outside of visible area
	edittext default opens soft keyboard
solving attempts:
	using custom edittext to suppress opening of soft keyboard  
	create custom edittext 
		override ondraw for drawing line numbers
		implement custom scroll
		zoom only scaled the canvas, but not the text
		realize now: shouhld have set text size, then it would have scaled correctly
	use library twoDScrollView as parent view to standard edittext
		only supports on child
		touch events got mixed up?
	use linear layout with custom scroll
		put textview for line numbers inside
		put edittext inside next to textview
		calculate container width from edittext
		calculation often times wrong
		trying to scroll to cursor when typing goes wrong at end of line: edittext still calculates new cursor position in next line from default wrapping behavior
		when adding line at bottom: should scroll new line so that is visible: not working, edittext doesn't now new height bevor drawing
		also problem upon fragment first showing: edittext doesn''t now how many lines it has upon instantitian with text 
		can't set container height and can't set line numbers
		can't scroll in viewer, can only scroll in editor after editing something as the edittext then updates and knows its height

\section{Keyboard}
The row and the grid editor each use different symbol keyboards. The keys of the grid editor keyboard feature stitch symbols and a delete button. Keys can be toggled to an active state --- only one key at a time can be active. While a key is active, touching the grid will lead to the string corresponsing with the active key being added to the pattern at the location of thetouched cell. Since empty cells contain the designated empty character ``Z'', deletion works in the same way as setting a symbol on the grid. The keyboard is implemented using a Gridview\footnote{\url{https://developer.android.com/reference/android/widget/GridView.html}}, a default Android component to display a collection of items in a grid with equal spacing between all items. The gridview also by default supports vertical scrolling. A grid item consists of text set on a button of the class KnittingFontButton, a custom class extending Android’s own Button widget. The custom button sets the knitting font to display its string title as a knitting symbol. \todo{refer to symbol chart here}

In the row editor the keyboard is divided in three sections. One section contains the stitch symbols, one a number pad and one an enter and a backspace button. Pressing a key on either number pad or symbols section apprends the corresponding string or number to the editor at the current positoin of the cursor. The enter and backspace button call the system’s enter and backspace key events from Android’s software keyboard and do therefore not require custom handling, but only to be forwarded to the editor.

The symbols sections is also a Gridview, although with less columns than in the grid editor. The numpad uses the CalculatorPadLayout from Rahul Parsani's Material Calculator project\footnote{\url{https://github.com/rahulparsani/material-calculator}}. The CalculatorPadLayout takes a number of child views, in this case KnittingFontButtons, as well as arguments for row and column count. It then calculates the size of the child views, so that all are equal in size. There are multiple reasons for using a custom Viewgroup here instead of a Gridview. A Gridview uses an adapter to handle the display of the data and possible events connected to the data items. It supports changes in the collection and offers methods to notify the adapter to redraw the grid after data changes. Writing such an adapter class is unnecessary since the number buttons in the numpad will not change. Each button also calls the same method, an individual handling of onClick events is therefore superfluous. Additionally, a Gridview always makes its items scrollable by default, something that is , in the author's experience, not part of the standard behavior of a numpad, even on small screen sizes. A LinearLayout, a layout that displays its children vertically or horizontally, could be used there too, but would increase the number of layouts needed to be rendered on the screen. This is generally something to avoid, since views are quite resource intensive in Android (\cite{android_optimizing_layouts}) and can cause the app to lag. Lastly, the enter and backspace buttons are displayed in a single LinearLayout.

\section{Row Counter}
counts rows in a pattern
buttons for increase and decrease row counter
can be reset with overflow action button
ideally: current row should be highlighted in pattern in grid and row format
+ upon current row change current row should be scrolled into center of screen if not in visible area
only works in grid view
row format still has issues with knowing how high it is upon instantiation
see row format setion

\section{Grid pattern format: GridEditorView}
For displaying the grid format I first looked into Android’s own grid implementations, the Gridview and the TableLayout. The TableLayout is similar to HTML’s table tag and is displays elements in rows and columns. It should only be used if the underlying views or data will not change. A Gridview, as used for the symbol keyboard, seems an optimal solution for a grid. Unfortunately it is not possible to implement frozen cells, so that the first row and column stick to the edges of the screen to display the row and column numbers.

I then took inspiration from the app Knitting Pattern Maker, introduced in the background section, and Google’s developer guide to dragging and scaling, for which they published a sample project implementing those features on an OpenGL canvas that included axis labels.

For the prototype I implemented my own subclass of View. In it I draw the canvas with the line and row numbers, the lines for the grid and the stitch symbols. For the symbols I use the canvas’ drawText() method, which takes a Paint parameter that has the custom knitting font set. The position of touched cells is calculated from the pixel input of the touch event. The finger pinch zoom is implemented using Android’s ScaleGestureListener interface. The onScale method takes the a ScaleDetector as parameter which contains the coordinates relevant to the scaling and the scale factor. The scale factor from the event is then saved and used when drawing the canvas in onDraw to scale the drawing operations. The SimpleGestureListener interface is used for the two-dimensional dragging of the grid. The dragged distances are clamped in the onScroll method and then applied as translation during the drawing of the canvas.
The GridEditorView also has a method to scroll the current line to the center and draw a highlight on the current row in the onDraw method which are used when the grid is displayed in the viewer.

\section{Row pattern format: RowEditorLinearLayout}
The row editor consists of a the RowLinearLayout class, a custom LinearLayout. This layout implements two-dimensional scrolling which uses a native Scroller. The scroll distance is calculated inside the onTouchEvent method and then scrolled by the scroller. It houses one custom EditTexts, which comes with text operations such as selecting, cut, copy, and pasting and a custom TextView. The layout is set programmatically to extend beyond the visible screen and make itself scrollable when the children are bigger than the visible area.

The LinedEditorEditText extends EditText to draw the background for the odd and even lines and to set the knitting font, as well as the highlight for the current row when in the viewer. On the left of the EditText is the LineNumberTextView, a custom implementation of Android’s TextView that contains the line numbers. When a new line is added to the editor, the line numbers get a line added as well.

\section{Editor Activity}
This activity simply contains a FrameLayout to programmatically add the grid and row editor fragments to is and allow easy switching between the visible fragments. The menu contains buttons for switching the editors, saving, the overflow menu, which are the three vertical dots, and, when the grid is visible, to set the grid size. Buttons for deleting and renaming the pattern are located in the overflow menu.

Before the views are switched the activity calls the savePattern method. This method checks whether the pattern has been edited and then saves it to local storage.
When the user tries exits the activity with the software back button or the home button it is checked again for changes. Are any found then the activity will display a dialog to ask the user if he wants to save the changes before exiting.

\subsection{Editor Fragments}
There are two fragments in the Editor Activity: each of the two editor formats has its own fragment that displays the corresponding keyboard. The fragments handle saving, loading, and updating of the pattern data as well as the keyboard presses.
The grid format fragment also displays the dialog for setting a new grid size.

\section{Viewer Activity}
The Viewer activity houses the row counter a placeholder for the grid and row fragments. The counter consists of a simple TextView and Buttons, which show the current line number and increase or decrease the counter. In the activity’s menu top the user can also scroll to the current line, a feature that only the grid implements so far, and find a button to reset the counter in the overflow menu to the right.

The fragments are set during runtime programmatically and can be switched with a menu button. Both fragments indicate the current row number with a highlight on the row.