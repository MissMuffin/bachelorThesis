\textit{Google’s IDE Android Studio 2.1.2 is used for the implementation of the Android app prototype}

\section{Stitch symbols}
There are two possible ways to display a symbol of any kind in views in Android: one is to use drawables, image resources and the other to use text with a custom font. I decided to go with the second approach, since that would allow to save and display patterns using simple strings. Furthermore fonts are rendered during runtime with antialiasing, meaning the quality of the displayed symbol is consistent across screen sizes, whereas with drawables files with different resolutions would be needed to optimize both resources usage when loading the drawables into memory and view quality.
A font consists of glyphs, which contain information how a character is to be displayed. It is also possible to have ligatures in the font, meaning that multiple character in a specific combination will be represented by a single glyph rather than three individual glyphs. Such an example is the String “fi” which displays as “fi” when using the font Roboto. This can be used to display more stitches than there are keys available on the keyboard. To fit the time constraints of this thesis I will limit stitch symbols to single letter glyphs.
I used the open source software Font Forge to create the knitting font for this thesis.

\section{Pattern}
Using a custom font for the stitch symbols allows to represent patterns as combinations of characters. Within the app prototype I use three different pattern formats: one for the Pattern POJO (Plain Old Java Object) which is used for the persistent storage, one for the row format, and one for the grid format.

The grid format uses a two-dimensional String array of columns and rows and can  be likened to the way a pattern chart is displayed on paper. Each cell is filled with a String representing a stitch.

The row format is one String that is used with Android’s EditText widget. The format implements the shortened pattern rows described in the design chapter of this thesis. An EditText can display multiline text and does so by adding a line feed $\\n$ at the appropriate place in the String. Rows can be distinguished by the $\\n$ following a combinations of letters.

The Pattern POJO contains a field for a String Array of pattern chart rows that, like the pure row format, use the shortened rows for representing a pattern.
The pattern is converted between the different formats by using the class KnittingParser. This class provides static methods for the conversion between grid, row and POJO format.

\section{Persistent Disk Storage}
There are multiple ways persistent storage can be implemented in Android. A common choice is to use a SQLite database, which Android natively supports. Another would be to save files to internal or external storage, which many phones have by way of SD card.
I decided to save the patterns as files to internal storage --- the pattern is saved in the default local directory Android gives the app. For this the Pattern POJO is serialized using Google’s JSON library Gson, which handles the writing, reading and conversion of the files to Java objects and vice versa. Gson supports the usage of Java generics and can map JSON data to POJOs while maintaining inheritance hierarchies.

The Pattern POJO defined in the prototype contains fields for the pattern rows, the total number of columns and rows, and the current row from the row counter with getters and setters for all of the fields. A pattern object’s default state after initialization contains a pattern of size 10 x 10 that is filled with  the character representing an empty stitch. The empty stitch character in the prototype is ‘u’.

It inherits from the class Metadata which contains both a UUID representing the pattern id and the name the user gives the pattern. When storing on disk Pattern POJOs are converted to JSON using Gson and saved with the id as filename. The metadata from the pattern is then added to an ArrayList of Metadatas which is saved in the same local app directory and acts as an index of all patterns saved on the device. Using an index file increases performance, since to get a list of the existing patterns not all pattern files have to be loaded, but just the one file containing the ArrayList of Metadatas. Individual pattern can then be loaded using the id saved in the patterns Metadata.

\section{Keyboard}
The row and the grid editor use different keyboards each. The keyboard of the grid editor features stitch symbols and a delete button. The symbols and the delete button can be toggled to be in the active state. While a symbol is active, touching the grid will lead to the active symbol being added to the pattern at the touched cell. Since empty cells contain the designated empty character ‘.’, deletion works in the same way as writing. The keyboard is implemented using a Gridview, a default Android component to display a collection of items in a grid with equal spacing between the items, that also features scrolling. A grid item consists of text set on a KnittingFontButton, a custom view that I defined that extends Android’s own Button view. The custom button sets the custom knitting font defined for the project.

In the row editor there are three sections of the keyboard. One for the symbols, one for numbers and one that includes the enter and backspace buttons. Pressing a symbol and number button will append the character or the number to the editor. The enter and backspace button call the system’s enter and backspace key events from Android’s software keyboard.
The symbols sections is also a Gridview, although with less columns than in the grid editor. For the numpad I use the Viewgroup class CalculatorPadLayout form Rahul Parsani. The viewgroup takes a number of child views, in this case KnittingFontButtons, as well as arguments for row and column count. It then calculates the size of the child views so, that they are all equal in size and distribution. There are multiple reasons for using a custom Viewgroup here instead of a Gridview. A Gridview uses an Adapter class to populate the items in it with a collection and handle the onClick event of these items. It supports changes in the collection and offers methods to notify the adapter to redraw the grid after data changes. Writing such an adapter class is unnecessary since the number buttons in the numpad will not change. Each button also calls the same method, an individual handling of onClick events is therefore superfluous. Additionally, a Gridview always makes its items scrollable by default, something that we don’t want with a numpad even on different screen sizes. A LinearLayout, a Viewgroup that displays its children one after another, either vertically, or horizontally, could be used there too, but would increase the number of layouts that need to be rendered on the screen. That is generally something to avoid, since views are quite resource intensive in Android and can cause lag in the app. Lastly, the enter and backspace buttons are displayed in a single LinearLayout.

All buttons use a drawable for their background to indicate pressed and clicked states with a filled circle round the pressed button.

\section{Grid pattern format: GridEditorView}
For displaying the grid format I first looked into Android’s own grid implementations, the Gridview and the TableLayout. The TableLayout is similar to HTML’s table tag and is displays elements in rows and columns. It should only be used if the underlying views or data will not change. A Gridview, as used for the symbol keyboard, seems an optimal solution for a grid. Unfortunately it is not possible to implement frozen cells, so that the first row and column stick to the edges of the screen to display the row and column numbers.

I then took inspiration from the app Knitting Pattern Maker, introduced in the background section, and Google’s developer guide to dragging and scaling, for which they published a sample project implementing those features on an OpenGL canvas that included axis labels.

For the prototype I implemented my own subclass of View. In it I draw the canvas with the line and row numbers, the lines for the grid and the stitch symbols. For the symbols I use the canvas’ drawText() method, which takes a Paint parameter that has the custom knitting font set. The position of touched cells is calculated from the pixel input of the touch event. The finger pinch zoom is implemented using Android’s ScaleGestureListener interface. The onScale method takes the a ScaleDetector as parameter which contains the coordinates relevant to the scaling and the scale factor. The scale factor from the event is then saved and used when drawing the canvas in onDraw to scale the drawing operations. The SimpleGestureListener interface is used for the two-dimensional dragging of the grid. The dragged distances are clamped in the onScroll method and then applied as translation during the drawing of the canvas.
The GridEditorView also has a method to scroll the current line to the center and draw a highlight on the current row in the onDraw method which are used when the grid is displayed in the viewer.

\section{Row pattern format: RowEditorLinearLayout}
The row editor consists of a the RowLinearLayout class, a custom LinearLayout. This layout implements two-dimensional scrolling which uses a native Scroller. The scroll distance is calculated inside the onTouchEvent method and then scrolled by the scroller. It houses one custom EditTexts, which comes with text operations such as selecting, cut, copy, and pasting and a custom TextView. The layout is set programmatically to extend beyond the visible screen and make itself scrollable when the children are bigger than the visible area.

The LinedEditorEditText extends EditText to draw the background for the odd and even lines and to set the knitting font, as well as the highlight for the current row when in the viewer. On the left of the EditText is the LineNumberTextView, a custom implementation of Android’s TextView that contains the line numbers. When a new line is added to the editor, the line numbers get a line added as well.

\section{Editor Activity}
This activity simply contains a FrameLayout to programmatically add the grid and row editor fragments to is and allow easy switching between the visible fragments. The menu contains buttons for switching the editors, saving, the overflow menu, which are the three vertical dots, and, when the grid is visible, to set the grid size. Buttons for deleting and renaming the pattern are located in the overflow menu.

Before the views are switched the activity calls the savePattern method. This method checks whether the pattern has been edited and then saves it to local storage.
When the user tries exits the activity with the software back button or the home button it is checked again for changes. Are any found then the activity will display a dialog to ask the user if he wants to save the changes before exiting.

\subsection{Editor Fragments}
There are two fragments in the Editor Activity: each of the two editor formats has its own fragment that displays the corresponding keyboard. The fragments handle saving, loading, and updating of the pattern data as well as the keyboard presses.
The grid format fragment also displays the dialog for setting a new grid size.

\section{Viewer Activity}
The Viewer activity houses the row counter a placeholder for the grid and row fragments. The counter consists of a simple TextView and Buttons, which show the current line number and increase or decrease the counter. In the activity’s menu top the user can also scroll to the current line, a feature that only the grid implements so far, and find a button to reset the counter in the overflow menu to the right.

The fragments are set during runtime programmatically and can be switched with a menu button. Both fragments indicate the current row number with a highlight on the row.