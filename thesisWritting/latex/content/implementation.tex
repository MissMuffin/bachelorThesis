\textit{Google’s IDE Android Studio 2.1.2 was used for the implementation of the Android app prototype}

\section{Stitch symbols}
There are different ways to display a stitch symbol in an Android app --- this section will give an overview of the possiblities and the solution chosen for the prototype. 
The most naive way to display any text or image would be to implement the drawing of the content, pixel by pixel, in a custom view. This solution will be disregarded for this thesis, since the View class already defines the onDraw() method that can be overridden, which contains a Canvas object that offers methods to draw text and image content. Image content can be specified in an Android project in the res directory under the drawable directory. This directory contains the image resources of the app, the drawables --- this applies for icons, custom images, and other image content, excempting the launcher icon of the app, which is located in the mipmap directory. One way to use stitch symbols in an Android app would be to add every symbol as a drawable and then draw them on a view's canvas. For this a drawable would be needed for each individual stitch symbol, as well as way to map these drawable files to values that can be efficiently stored in a \gls{JSON} file. The usage of many drawables in an app would also lead to an increase in app size, resulting in longer download times and larger storage demands. Both are an inconvinience to the user and can be problematic on older devices with less powerful hardware, making the app unsusable in the worst case scenario.
The other option for displaying symbols is to create a custom \gls{TTF} with glyphs for stitch symbols that is applied to text in the app. This is the solution used in the prototype. It offers several advantages over using image resources. For one, when using drawables it might be necessary to include several versions of the same file to assure that they are displayed correctly on devices with different screen densities (\cite{android_densities}). This is not needed for text with a custom font: the glyphs are defined by Beziér curves, which are correctly rendered by the system for the individual screen densities. \todo{ref here?} The usage of a font also allows to write each stitch as a characters, simplifying the process of saving a pattern to a \gls{JSON} file. For OpenType fonts, which \gls{TTF} belongs to, Microsoft recommends 64000 as the maximum number of glyphs a font should contain (\cite{microsoft_max_glyphs}). This allows for a plethora of stitch symbols. The open source program FontForge \footnote{\url{https://fontforge.github.io/en-US/} (last accessed: 08-10-2016)} was used creation of the custom \gls{TTF} knitting font used in the protoype. The knitting font contains a selection of 16 stitch symbols whose glyphs were defined by the author herself. The glyphs and their corresponding UTF-8 characters can be found in the Appendix A: \todo{ref here!}.

\section{Pattern}
Using a custom font for the stitch symbols allows to represent patterns as combinations of characters. The actual pattern chart is saved to \gls{JSON} as an Array of Strings, where each String represents one row in the chart. The 
 Within the app prototype I use three different pattern formats: one for the Pattern POJO (Plain Old Java Object) which is used for the persistent storage, one for the row format, and one for the grid format.

The grid format uses a two-dimensional String array of columns and rows and can  be likened to the way a pattern chart is displayed on paper. Each cell is filled with a String representing a stitch.

The row format is one String that is used with Android’s EditText widget. The format implements the shortened pattern rows described in the design chapter of this thesis. An EditText can display multiline text and does so by adding a line feed $\\n$ at the appropriate place in the String. Rows can be distinguished by the $\\n$ following a combinations of letters.

The Pattern POJO contains a field for a String Array of pattern chart rows that, like the pure row format, use the shortened rows for representing a pattern.
The pattern is converted between the different formats by using the class KnittingParser. This class provides static methods for the conversion between grid, row and POJO format.

\section{Displaying a Pattern}

\subsection{Grid Format}
possible solutions:
	androids gridview
		no frozen columns/rows for axes
		only vertical scroll
		could be implemented with custom width setting and adding a custom scroller
		+ textviews for axes that are scrolled and scaled with the gridview
		would be very finicky to synchronize everzthing
		gridview is intended to completely fill screen, no views next to it
	androids table layout
		name says table
		more used for layout positoining like html's table element
	custom view
		did this in the end
class subclassed from view
drawing grid and grid axes on canvas in ondraw
2d scroll/drag/fling in android not natively supported for anything except web view
what is web view
custom scroll/drag/fling needs to be implemented
difference pan, scroll, fling
using ScaleGestureDetector.SimpleOnScaleGestureListener and GestureDetector.SimpleOnGestureListener in onTouchEvent()
-> for scaling and dragging
how drag implemented:
inspired by app knitting chart maker and google sample project interactive chart demo
	ATTACH PROJECT
	offset from dragging motion event is saved
	ondraw translates canvas by that offset
	same with scale
	both need to be limited: scale would be too big or too small: hard coded limits
	dragging offset is clamped after after offset calculations between 0 and max offset
	offset initialized with 0,0
	maxoffset = visible area - content area
	dragged distance needs to be substracted from offset ???
	scale factor is saved and simply applied to all drawing operations on the canvas and the content rect's size
pattern: array of array of strings
on touch: calculate cell from pixel positoin of touch event and add selected symbol to symbol array at that position

\subsection{Row Format}
requirements: 
	editor should have standard text editor functionalities: copy, paste, cut, select, multi lines, scollable horizontally and zoom
problem:
	texteditor has standard functions (cut, copy, select, paste) 
	also has multi lines as well as horizontal scroll
	but doesn't support multi line and hori scroll at the same time
	if scroll, then only single line
	if multi line, then vertical scroll and wrap at the end of the screen, no content outside of visible area
	edittext default opens soft keyboard
solving attempts:
	using custom edittext to suppress opening of soft keyboard  
	create custom edittext 
		override ondraw for drawing line numbers
		implement custom scroll
		zoom only scaled the canvas, but not the text
		realize now: shouhld have set text size, then it would have scaled correctly
	use library twoDScrollView as parent view to standard edittext
		only supports on child
		touch events got mixed up?
	use linear layout with custom scroll
		put textview for line numbers inside
		put edittext inside next to textview
		calculate container width from edittext
		calculation often times wrong
		trying to scroll to cursor when typing goes wrong at end of line: edittext still calculates new cursor position in next line from default wrapping behavior
		when adding line at bottom: should scroll new line so that is visible: not working, edittext doesn't now new height bevor drawing
		also problem upon fragment first showing: edittext doesn''t now how many lines it has upon instantitian with text 
		can't set container height and can't set line numbers
		can't scroll in viewer, can only scroll in editor after editing something as the edittext then updates and knows its height

\section{Persistent Disk Storage}
import: check file type??? not handled yet, app crash

There are multiple ways persistent storage can be implemented in Android. A common choice is to use a SQLite database, which Android natively supports. Another would be to save files to internal or external storage, which many phones have by way of SD card.
I decided to save the patterns as files to internal storage --- the pattern is saved in the default local directory Android gives the app. For this the Pattern POJO is serialized using Google’s JSON library Gson, which handles the writing, reading and conversion of the files to Java objects and vice versa. Gson supports the usage of Java generics and can map JSON data to POJOs while maintaining inheritance hierarchies.

The Pattern POJO defined in the prototype contains fields for the pattern rows, the total number of columns and rows, and the current row from the row counter with getters and setters for all of the fields. A pattern object’s default state after initialization contains a pattern of size 10 x 10 that is filled with  the character representing an empty stitch. The empty stitch character in the prototype is ‘u’.

It inherits from the class Metadata which contains both a UUID representing the pattern id and the name the user gives the pattern. When storing on disk Pattern POJOs are converted to JSON using Gson and saved with the id as filename. The metadata from the pattern is then added to an ArrayList of Metadatas which is saved in the same local app directory and acts as an index of all patterns saved on the device. Using an index file increases performance, since to get a list of the existing patterns not all pattern files have to be loaded, but just the one file containing the ArrayList of Metadatas. Individual pattern can then be loaded using the id saved in the patterns Metadata.

\section{Keyboard}
The row and the grid editor use different keyboards each. The keyboard of the grid editor features stitch symbols and a delete button. The symbols and the delete button can be toggled to be in the active state. While a symbol is active, touching the grid will lead to the active symbol being added to the pattern at the touched cell. Since empty cells contain the designated empty character ‘.’, deletion works in the same way as writing. The keyboard is implemented using a Gridview, a default Android component to display a collection of items in a grid with equal spacing between the items, that also features scrolling. A grid item consists of text set on a KnittingFontButton, a custom view that I defined that extends Android’s own Button view. The custom button sets the custom knitting font defined for the project.

In the row editor there are three sections of the keyboard. One for the symbols, one for numbers and one that includes the enter and backspace buttons. Pressing a symbol and number button will append the character or the number to the editor. The enter and backspace button call the system’s enter and backspace key events from Android’s software keyboard.
The symbols sections is also a Gridview, although with less columns than in the grid editor. For the numpad I use the Viewgroup class CalculatorPadLayout form Rahul Parsani. The viewgroup takes a number of child views, in this case KnittingFontButtons, as well as arguments for row and column count. It then calculates the size of the child views so, that they are all equal in size and distribution. There are multiple reasons for using a custom Viewgroup here instead of a Gridview. A Gridview uses an Adapter class to populate the items in it with a collection and handle the onClick event of these items. It supports changes in the collection and offers methods to notify the adapter to redraw the grid after data changes. Writing such an adapter class is unnecessary since the number buttons in the numpad will not change. Each button also calls the same method, an individual handling of onClick events is therefore superfluous. Additionally, a Gridview always makes its items scrollable by default, something that we don’t want with a numpad even on different screen sizes. A LinearLayout, a Viewgroup that displays its children one after another, either vertically, or horizontally, could be used there too, but would increase the number of layouts that need to be rendered on the screen. That is generally something to avoid, since views are quite resource intensive in Android and can cause lag in the app. Lastly, the enter and backspace buttons are displayed in a single LinearLayout.

All buttons use a drawable for their background to indicate pressed and clicked states with a filled circle round the pressed button.

\section{Row Counter}
counts rows in a pattern
buttons for increase and decrease row counter
can be reset with overflow action button
ideally: current row should be highlighted in pattern in grid and row format
+ upon current row change current row should be scrolled into center of screen if not in visible area
only works in grid view
row format still has issues with knowing how high it is upon instantiation
see row format setion

\section{Grid pattern format: GridEditorView}
For displaying the grid format I first looked into Android’s own grid implementations, the Gridview and the TableLayout. The TableLayout is similar to HTML’s table tag and is displays elements in rows and columns. It should only be used if the underlying views or data will not change. A Gridview, as used for the symbol keyboard, seems an optimal solution for a grid. Unfortunately it is not possible to implement frozen cells, so that the first row and column stick to the edges of the screen to display the row and column numbers.

I then took inspiration from the app Knitting Pattern Maker, introduced in the background section, and Google’s developer guide to dragging and scaling, for which they published a sample project implementing those features on an OpenGL canvas that included axis labels.

For the prototype I implemented my own subclass of View. In it I draw the canvas with the line and row numbers, the lines for the grid and the stitch symbols. For the symbols I use the canvas’ drawText() method, which takes a Paint parameter that has the custom knitting font set. The position of touched cells is calculated from the pixel input of the touch event. The finger pinch zoom is implemented using Android’s ScaleGestureListener interface. The onScale method takes the a ScaleDetector as parameter which contains the coordinates relevant to the scaling and the scale factor. The scale factor from the event is then saved and used when drawing the canvas in onDraw to scale the drawing operations. The SimpleGestureListener interface is used for the two-dimensional dragging of the grid. The dragged distances are clamped in the onScroll method and then applied as translation during the drawing of the canvas.
The GridEditorView also has a method to scroll the current line to the center and draw a highlight on the current row in the onDraw method which are used when the grid is displayed in the viewer.

\section{Row pattern format: RowEditorLinearLayout}
The row editor consists of a the RowLinearLayout class, a custom LinearLayout. This layout implements two-dimensional scrolling which uses a native Scroller. The scroll distance is calculated inside the onTouchEvent method and then scrolled by the scroller. It houses one custom EditTexts, which comes with text operations such as selecting, cut, copy, and pasting and a custom TextView. The layout is set programmatically to extend beyond the visible screen and make itself scrollable when the children are bigger than the visible area.

The LinedEditorEditText extends EditText to draw the background for the odd and even lines and to set the knitting font, as well as the highlight for the current row when in the viewer. On the left of the EditText is the LineNumberTextView, a custom implementation of Android’s TextView that contains the line numbers. When a new line is added to the editor, the line numbers get a line added as well.

\section{Editor Activity}
This activity simply contains a FrameLayout to programmatically add the grid and row editor fragments to is and allow easy switching between the visible fragments. The menu contains buttons for switching the editors, saving, the overflow menu, which are the three vertical dots, and, when the grid is visible, to set the grid size. Buttons for deleting and renaming the pattern are located in the overflow menu.

Before the views are switched the activity calls the savePattern method. This method checks whether the pattern has been edited and then saves it to local storage.
When the user tries exits the activity with the software back button or the home button it is checked again for changes. Are any found then the activity will display a dialog to ask the user if he wants to save the changes before exiting.

\subsection{Editor Fragments}
There are two fragments in the Editor Activity: each of the two editor formats has its own fragment that displays the corresponding keyboard. The fragments handle saving, loading, and updating of the pattern data as well as the keyboard presses.
The grid format fragment also displays the dialog for setting a new grid size.

\section{Viewer Activity}
The Viewer activity houses the row counter a placeholder for the grid and row fragments. The counter consists of a simple TextView and Buttons, which show the current line number and increase or decrease the counter. In the activity’s menu top the user can also scroll to the current line, a feature that only the grid implements so far, and find a button to reset the counter in the overflow menu to the right.

The fragments are set during runtime programmatically and can be switched with a menu button. Both fragments indicate the current row number with a highlight on the row.